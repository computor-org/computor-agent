"""
Tutor Comments Service for the Tutor AI Agent.

Handles reading and writing tutor comments about students.
Comments are private notes that tutors/lecturers can add
to track student progress, issues, or other notes.
"""

import logging
from dataclasses import dataclass, field
from datetime import datetime
from typing import Any, Optional

logger = logging.getLogger(__name__)


@dataclass
class TutorComment:
    """
    A tutor comment about a course member.

    Attributes:
        id: Comment ID
        course_member_id: The student this comment is about
        content: Comment text
        author_id: ID of tutor/lecturer who wrote it
        author_name: Name of the author
        created_at: When the comment was created
        updated_at: When the comment was last updated
        is_ai_generated: Whether this comment was generated by AI
    """
    id: str
    course_member_id: str
    content: str
    author_id: Optional[str] = None
    author_name: Optional[str] = None
    created_at: Optional[datetime] = None
    updated_at: Optional[datetime] = None
    is_ai_generated: bool = False

    def format_for_prompt(self) -> str:
        """Format comment for LLM prompt."""
        date_str = ""
        if self.created_at:
            date_str = f" ({self.created_at.strftime('%Y-%m-%d')})"

        author = self.author_name or "Tutor"
        if self.is_ai_generated:
            author = "AI Tutor"

        return f"[{author}{date_str}]: {self.content}"


class CommentsService:
    """
    Service for managing tutor comments about students.

    Provides methods to:
    - List comments for a course member
    - Create new comments (including AI-generated notes)
    - Update existing comments
    - Delete comments

    Usage:
        service = CommentsService(client)

        # Get comments about a student
        comments = await service.get_comments(course_member_id)

        # Add a new comment
        comment = await service.add_comment(
            course_member_id,
            "Student is struggling with recursion concepts."
        )

        # Add AI-generated note
        comment = await service.add_ai_note(
            course_member_id,
            "Helped student understand recursion with visual examples."
        )
    """

    # Prefix for AI-generated comments
    AI_COMMENT_PREFIX = "[AI Note] "

    def __init__(self, client: Any) -> None:
        """
        Initialize the service.

        Args:
            client: ComputorClient instance
        """
        self.client = client

    async def get_comments(
        self,
        course_member_id: str,
        *,
        limit: Optional[int] = None,
        include_ai_notes: bool = True,
    ) -> list[TutorComment]:
        """
        Get all comments for a course member.

        Args:
            course_member_id: Course member ID
            limit: Maximum number of comments to return
            include_ai_notes: Include AI-generated notes

        Returns:
            List of TutorComment objects, newest first
        """
        try:
            comments = await self.client.course_member_comments.list(
                course_member_id=course_member_id,
            )

            if not comments:
                return []

            result = []
            for c in comments:
                content = getattr(c, "content", "") or ""

                # Check if AI-generated
                is_ai = content.startswith(self.AI_COMMENT_PREFIX)
                if is_ai and not include_ai_notes:
                    continue

                # Clean content
                if is_ai:
                    content = content[len(self.AI_COMMENT_PREFIX):]

                # Parse dates
                created_at = self._parse_datetime(getattr(c, "created_at", None))
                updated_at = self._parse_datetime(getattr(c, "updated_at", None))

                # Get author info
                author = getattr(c, "author", None)
                author_name = None
                if author:
                    given = getattr(author, "given_name", "") or ""
                    family = getattr(author, "family_name", "") or ""
                    author_name = f"{given} {family}".strip() or None

                result.append(TutorComment(
                    id=c.id,
                    course_member_id=course_member_id,
                    content=content,
                    author_id=getattr(c, "author_id", None),
                    author_name=author_name,
                    created_at=created_at,
                    updated_at=updated_at,
                    is_ai_generated=is_ai,
                ))

            # Sort by created_at, newest first
            result.sort(
                key=lambda x: x.created_at or datetime.min,
                reverse=True,
            )

            if limit:
                result = result[:limit]

            return result

        except Exception as e:
            logger.warning(f"Failed to get comments for {course_member_id}: {e}")
            return []

    async def add_comment(
        self,
        course_member_id: str,
        content: str,
    ) -> Optional[TutorComment]:
        """
        Add a new comment about a course member.

        Args:
            course_member_id: Course member ID
            content: Comment text

        Returns:
            Created TutorComment or None on failure
        """
        try:
            created = await self.client.course_member_comments.create(
                data={
                    "course_member_id": course_member_id,
                    "content": content,
                }
            )

            if not created:
                return None

            return TutorComment(
                id=created.id,
                course_member_id=course_member_id,
                content=content,
                created_at=self._parse_datetime(getattr(created, "created_at", None)),
            )

        except Exception as e:
            logger.error(f"Failed to add comment for {course_member_id}: {e}")
            return None

    async def add_ai_note(
        self,
        course_member_id: str,
        note: str,
    ) -> Optional[TutorComment]:
        """
        Add an AI-generated note about a course member.

        AI notes are prefixed to distinguish them from human comments.

        Args:
            course_member_id: Course member ID
            note: Note text

        Returns:
            Created TutorComment or None on failure
        """
        content = f"{self.AI_COMMENT_PREFIX}{note}"
        comment = await self.add_comment(course_member_id, content)
        if comment:
            comment.is_ai_generated = True
            comment.content = note  # Remove prefix from returned object
        return comment

    async def update_comment(
        self,
        comment_id: str,
        content: str,
    ) -> Optional[TutorComment]:
        """
        Update an existing comment.

        Args:
            comment_id: Comment ID
            content: New content

        Returns:
            Updated TutorComment or None on failure
        """
        try:
            updated = await self.client.course_member_comments.update(
                id=comment_id,
                data={"content": content},
            )

            if not updated:
                return None

            return TutorComment(
                id=updated.id,
                course_member_id=getattr(updated, "course_member_id", ""),
                content=content,
                updated_at=self._parse_datetime(getattr(updated, "updated_at", None)),
            )

        except Exception as e:
            logger.error(f"Failed to update comment {comment_id}: {e}")
            return None

    async def delete_comment(self, comment_id: str) -> bool:
        """
        Delete a comment.

        Args:
            comment_id: Comment ID

        Returns:
            True if deleted successfully
        """
        try:
            await self.client.course_member_comments.delete(id=comment_id)
            return True
        except Exception as e:
            logger.error(f"Failed to delete comment {comment_id}: {e}")
            return False

    async def get_ai_notes(
        self,
        course_member_id: str,
        *,
        limit: int = 5,
    ) -> list[TutorComment]:
        """
        Get only AI-generated notes for a course member.

        Args:
            course_member_id: Course member ID
            limit: Maximum number of notes

        Returns:
            List of AI-generated comments
        """
        all_comments = await self.get_comments(
            course_member_id,
            include_ai_notes=True,
        )
        ai_notes = [c for c in all_comments if c.is_ai_generated]
        return ai_notes[:limit]

    async def format_comments_for_prompt(
        self,
        course_member_id: str,
        *,
        max_comments: int = 5,
        include_ai_notes: bool = True,
    ) -> str:
        """
        Get formatted comments for inclusion in LLM prompt.

        Args:
            course_member_id: Course member ID
            max_comments: Maximum comments to include
            include_ai_notes: Include AI-generated notes

        Returns:
            Formatted string for prompt
        """
        comments = await self.get_comments(
            course_member_id,
            limit=max_comments,
            include_ai_notes=include_ai_notes,
        )

        if not comments:
            return "(No tutor comments about this student)"

        parts = [f"=== Tutor Comments ({len(comments)}) ==="]
        for comment in comments:
            parts.append(comment.format_for_prompt())

        return "\n".join(parts)

    async def summarize_comments(
        self,
        course_member_id: str,
    ) -> dict[str, Any]:
        """
        Get a summary of comments for a course member.

        Returns:
            Dict with comment statistics
        """
        comments = await self.get_comments(course_member_id)

        return {
            "total_comments": len(comments),
            "ai_notes": sum(1 for c in comments if c.is_ai_generated),
            "human_comments": sum(1 for c in comments if not c.is_ai_generated),
            "latest_comment": comments[0].content[:100] if comments else None,
            "latest_date": comments[0].created_at if comments else None,
        }

    def _parse_datetime(self, value: Any) -> Optional[datetime]:
        """Parse datetime from various formats."""
        if value is None:
            return None

        if isinstance(value, datetime):
            return value

        if isinstance(value, str):
            try:
                return datetime.fromisoformat(value.replace("Z", "+00:00"))
            except ValueError:
                pass

        return None
